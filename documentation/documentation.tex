\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{enumerate}
\usepackage[utf8]{inputenc}
\usepackage{setspace}

\pagestyle{fancy}
\lhead{CS 428}
\chead{Conferenceware Documentation}
\rhead{5/1/2010}

%% yay doublespace
\doublespacing
\begin{document}
\part{Description}
Conferenceware is a web-based project for running a conference. Specifically, the software was designed to run the ACM Reflections|Projections conference. It is outfitted with features to support everything from registration to event staff scheduling to printing name badges for staff and attendees.  The software was designed to eliminate redundant actions, prevent the introduction of invalid data and, most importantly, make running a large conference easier.

%% Nick's WA4
\part{Process}

\indent Our team chose to follow the XP (eXtreme Programming) software development process. The fundamental tenets of this process include pair programming, test first design, user stories, and design simplicity. These tenets give us great flexibility and allow us to make changes to our requirements with minimal refactoring. Additionally changes to requirements can be handled with greater ease in XP because of the emphasis placed on the design of the software. All of these attributes of XP have helped guide our efforts and continue to simplify our workload while allowing individuals or pairs to work concurrently without adverse effects on one another.\\
\indent From an early stage we have applied pair programming to moderate success. We found that groups of two have helped each other to understand the programming language C\#, which most of us have never used, and the ins and outs of the framework. Our understanding has developed from the ability to bounce ideas off one another to make sense of the intricacies of the framework. In a specific case Brian and I worked together to develop the controller for our speaker object. This controller communicates with our database and has the responsibility of validating data passed to it upon the creation of a speaker in the schema. We also avoided errors in our implementation of the controller because we checked each other’s code as we wrote it. Simple formatting or typing errors that a compiler would catch, at the cost of time, did not make it into our code because the constant checks we employed on each other.\\
\indent Our combined effort also helped us solve issues with third party tools that neither of us had used before. Testing of our work necessitated the use of Microsoft SQL Server. A lightweight version of SQL Server (SQL Server Express) installed with our IDE (Integrated Development Environment). This version of SQL Server did not come with the usual suite of tools that make creating and populating databases easy, so we had to learn how to do this from the command line interface that comes with the product. This put both of our skills to the test as I tend to favor graphical user interfaces in the windows environment and my partner generally works at the command line on UNIX based systems. I had to use my knowledge of typical design patterns employed by Microsoft combined with my partner’s familiarity with command line tools.\\
\indent On a larger scale our choice to work in close proximity has allowed us to debug each other’s work and provide help insights that have saved individuals from relearning parts of the framework that someone else already figured out. This constant feedback has sped up development immeasurably and continues to shape our groups coding practice. As the code base continues to grow pair programming and constant group communication will serve as a means of enforcing conformity to our coding standard and insure that the simplicity of the code is maintained.\\
\indent Our focus on test first design has also helped define the direction of the project. Writing our tests first allows us to think critically about how all the pieces of our design fit together. Writing tests for individual pieces is relatively simple to do, which makes this style of design very appealing. If we find that we need to change the requirements or functionality of the code, whether mandated by knowledge discovered through design of the tests or by our end user, these changes will be simple to make because we have written the tests first and not the actual code. Once we have our tests in place we can begin crafting the code, and we can do periodical checks that our code behaves as desired by running the tests.\\
\indent Creating the unit tests first also gives us a good feel for our progress as we continue development. Each method that we create that fulfills a unit test brings us one step closer to the completion of the project and everyone can see that progress explicitly. The on the flip side of that coin that means that everyone knows what still needs to be accomplished. We can define goals for individuals or pairs to create the functionality demanded by the tests, and once we know that the goal has been accomplished once we can double check our progress with our tests.\\
\indent Just because we created our tests at the beginning does not mean that we stop creating tests as the project progresses. We have added tests as we go to insure that we cover as much of the code as possible, and when these situations do arise we take the opportunity to reassess our design. Our ability to reassess our design adds to the flexibility provided to us by XP. Continual checks on our progress have aided our understanding of our requirements as well. All these aspects of testing have made XP an invaluable tool in the construction of our system.\\
\indent XP has helped guide our development through user stories in addition to the testing already discussed. Our user stories have benefited us greatly particularly because as opposed to many groups we have an actual end user that will be using our product once we have finished working on it. We can communicate with these users regularly to determine if our work fulfills their desire for the final product. It also helps that our end users have had experience and know many of the pitfalls that may arise in the project. Our project will simply generalize much of the work that has been done by the end user over the past few years so that in the future the deployment of the final product need not be a stressful ordeal. Using this goal of eliminating stress on the part of our end user gives our project much needed focus, and the end user experience helps us avoid mistakes they have made in the past.\\
\indent User stories and the tasks that go with them also help break the project into more manageable chunks. We can distribute these bite size pieces among the group and allow each member to have feature ownership, but still keep a sense of collective ownership of the whole. The tasks allow us to see how individual pieces should come together to fulfill a user story, and that abstraction allows for us to meet our goal of design simplicity. This simplicity becomes evident in that complex dependencies have been minimized, and reusable code snippets become plentiful.\\
\indent Tying back to the idea of flexibility in requirements, we have tailored our user stories to those requirements that are the most independent. We cannot eliminate all interdependence among our stories, but we can minimize those dependencies. If a user story changes at a late point in development, we should be able to implement those changes with the least amount of work possible. This includes avoiding cascading changes to the code. One requirement change should not force us to change large portions of the code to implement the change. This should also mean that test we wrote before the change should hold after we change the code. Some test will have to change as well, but we can’t avoid that. \\
\indent The final tenet of XP that plays a significant role in our project is design simplicity. While some of the other tenets already facilitate that goal, design simplicity deserves its own category because of the decision required to keep things simple. One of the most important principles in keeping any design simple requires keeping the length of methods as short as possible. Not only does this give us a better idea of where the code faulted, should we find bugs, but it encapsulates the smallest actions that are performed together routinely. We can then use these over and over without rewriting code that does essentially the same thing over and over. Applying rules for clean code such as short methods and limited nesting increases code readability. This helps us to debug each other’s code because we can better read and understand code that someone wrote cleanly without long convoluted functions. \\
\indent Design simplicity also applies to the design and structure of the classes and larger hierarchies of the code. Organization of namespaces and classes allows outside viewers of the product to get a better understanding of what pieces do what without needing to look at all of them individually. A passive observer knows that a class designated as a factory will create instances of certain classes without needing to know how those classes are made. He knows that if that class resides within a kernel namespace then that class has something to do with the internal core workings of the program, but he does not need to know more than that. \\
\indent This simplicity of the design also allows for easy refactorings of the code. If one has a good understanding of the code, they can more easily make changes to the code that won’t break other functionality. These refactortings should also be simple in design and fit together with the rest of the system if the system exhibits high modularity.\\
\indent In total these four aspects make up the basis of sound software design methodology. XP’s relies on these tenets to insure that a team of engineers are working as effectively as possible toward completing the project on time and in a form that is highly maintainable.

\part{Requirements and Specifications}

\part{Architecture and Design}

\part{Future Plans}

\part{Appendix}
\end{document}
