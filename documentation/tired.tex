\documentclass[12pt,letterpaper]{article}
\usepackage{fancyhdr,geometry,setspace,mla,ulem}\pagestyle{fancy}

% 1 in margins
%\oddsidemargin 0.0in
\textwidth 6.25in
%\topmargin 0.5in
%\textheight 9.0in
%\headheight 0.0in
% double space
\doublespacing
\fancyhf{}
\begin{document}
\begin{mla}{James}{Wordelman}{Darko Marinov}{CS429}{\today}{Conferenceware
Development}
When running a real project of any size, engineers often find it difficult to hold to a prescribed set of rules. The methodologies prescribed by books may seem profound, and they can certainly offer a degree of inspiration, but they are not always practical for real life situations like Conference. \sout{The Conferenceware group has developed its own system in an effort to address these issues.} \textit{In order to address these issues, the Conferenceware group has developed its own unique system.} It has combined strategies to create a hybrid approach which may be broken up into three major stages: planning and learning, development and hand testing, and automated testing. 

Planning is essential to any highly data-centric application. Preparation should be done before any code is written, as it helps to define the structure and flow of data. It is a way of finding and preventing problems when testing is still in the early stages of development. With Conferenceware, planning is coordinated through an extensive database schema. This schema manages all the interconnected data, and discussions of the schema start any development iteration. Because the schema is so vital to the project, it is updated only when absolutely necessary.  Planning is therefore a difficult and delicate process, but it makes subsequent development run much more smoothly.

\sout{We have two major areas of focus when planning the database, which helps set the course for the project as a whole.} \textit{When planning the database, we set the course for the entire project by weighing two major areas of consideration.} First, we \sout{consider} \textit{approach} user interaction and usability\textit{. For these issues, we} \sout{by posing} \textit{pose} the following questions: What information would a user want to obtain from the system? What would he want to be able to put into it? How can we collect this data and ensure its validity without encumbering the user?  We may impose limits on the data because these limits allow \sout{the system to function optimally and verify information thoroughly.} \textit{us to prepare the system, ensuring optimal functionality and information verification.} \sout{They} \textit{The limits} also provide \textit{us with} concrete ranges \sout{to be implemented} \textit{which we can implement} into the schema. 

A programmer then plans and defines the schema using his own particular viewpoint.  He may regard certain bits of data as useful when an ordinary user would not see their relevance. For example, he can appreciate the value of unique numerical IDs for database entries. This feature may be helpful, but it does not figure into the user experience.  The programmer also evaluates how data is used in conjunction with other data, thus gleaning insight into the best way to define the database's table design. His objective is to keep similar data close together for optimizations and for the ease of database interactions.  By engaging in these tasks, he helps to create a robust and extensible schema that can serve as a plan to dictate the remainder of the program.

During the planning stage, the programmer often encounters obstacles which force him to pause planning and instead engage in learning. At times, he can simply refer to the appropriate text or consult a peer with more experience on the topic, but he may need to use his own skills to solve the more ambiguous problems.  For instance, when evaluating the discrepancies between two seemingly equivalent methods, he might employ impromptu code spikes.  This is a common strategy for comparing the performances of different methods.  When choosing the best method, the programmer should consider such factors as the number of unique lines of code, readability of the code, and general user friendliness. During this process, he may make mistakes that turn into lessons. For example, he may find that a brilliant idea has \sout{many} practical limits \textit{and be forced to try another approach}.

Alternative ideas and back up plans are extremely useful, but they may be difficult to keep track of, especially when programmers are working in large groups. \sout{Because of this, the Conferenceware team makes extensive use of certain tools for managing tasks while planning (and later maintaining and updating).} \textit{The Conferenceware team therefore needs a way to manage tasks while planning (and later maintaining and updating). They solve the problem by utilizing certain development tools.}   The main tool for this job is Redmine. Redmine is project management software written in Ruby using Rails.  It offers features like wikis, milestones, tickets and version control system integration, all of which help the team to track its progress. The tickets are particularly useful.  \sout{Tickets can be created for each task or user story that is under development.} \textit{Developers can create tickets for each task or user story that is under development.} They may also reference other tasks, which is useful for indicating relationships or signaling `blocks.' \textit{(}Blocking means that one task must be completed before the next one can be addressed by the team.\textit{)} The team can assign tasks to milestones as well so that they can measure progress easily against a timeline. They can also reference or resolve open tickets directly by using the correct comments in the integrated version control systems. In short, the team can use Redmine to formalize the planning in a trackable system.  

As soon as they have a good plan in mind and a schema in place, the Conferenceware group is ready to begin development. In many cases, they may take advantage of Visual Studio, which helps by providing base templates for certain bits of code. The group develops the entire product with the model-view-controller paradigm, allowing the code to be very well structured and separated. Finally, they divide the work amongst sub-teams, and programmers begin tackling the individual components. Since the components are essentially self-sufficient, each team can focus on \sout{its own work} \textit{developing} without worrying about what others are doing - provided that no one commits anything that would damage other people's code. A team is expected to take its component from the defined schema, connect logic to handle it in the controller, and then implement its own view to make it usable. As this occurs, a partner in the team is looking over the typist's shoulder to try to spot bugs on the fly. The teams also use Git source control management to track the code. With Git, they can create what is called a new branch. These branches take very little overhead (which is distinct from many other source control management systems), so programmers commonly create a new branch for every new feature under development. In doing this, they \sout{create} \textit{generate} private spaces where they can work without affecting or being affected by others' contributions.  As they work and commit incremental changes to their own branches, the main branch continues to function consistently and correctly.

Developers must understand two key components when typing and identifying bugs: the controller and the view. The controller provides the logic for the flow of the program. It interacts with both the models (objects created from the schema which hold data) and the views (the actual presentation layer - web pages, in this case). \sout{It} /textit{The controller also} makes decisions regarding a user's input data. When the data is valid, it should \sout{performed} \textit{choose to perform} the prescribed actions - for instance, creating something in the database. It should then bring the user to a new, useful location, such as the list of all related objects. \textit{Furthermore,} /sout{T}\textit{t}he controller \sout{also} decides what to do when the data is not valid. It might show the user a generally error page, or it might return the user to his original input with messages that explain the problems that have arisen. Finally, a controller chooses which view to show to the user. These views are the only things that the user ever actually sees. They provide and display all information, so they must be usable for the target audience. \sout{When both the controller and the view are in the hands of a developer, he can grasp the whole picture and work towards the use case that he is trying to solve.} \textit{The controller is the first piece of the puzzle which the developer must assemble, and it is essential because it governs the logic of the program.}

Once \sout{he} \textit{the developer} has obtained an initial version of the controller and view, /sout{the developer} /textit{he} begins to perform hand testing.  \sout{He uses the views manually to interact with the controller and enters both valid and invalid data.} \textit{He uses the views to interact with the controller manually and check its response to both valid and invalid data.} By doing so, he verifies that all the expected actions are indeed happening and that no crashes have occurred. His testing is by no means exhaustive, but it does work to indicate general problems or unexpected outcomes, and it lays a solid foundation for the next round of debugging.

\sout{Automated testing constitutes the process' final step.} \textit{The final step of the process is a series of automated tests.} \sout{The automated tests} \textit{These} exist primarily to stop regression, not to actually verify functionality. \sout{Once a controller has already been tested by hand, these series of exhaustive tests come into play. They are designed to take nothing about the controller for granted; even the existence of a response is not established until the test has proven and verified it.} \textit{They come into play one a controller has already been tested by hand, so they are designed to be exhaustive and take nothing for granted. Even the existence of a response is not established until the test has proven and verified it.}  The tests also check the side effects of various methods and verify the effects of the controller on the database. \sout{These measures are essential to a data driven application.} \textit{Rigorous automated testing helps ensure that a data driven application will actually work as intended.}

	The team must verify effects on error conditions as well. When it releases applications onto the World Wide Web, anything can and will happen. As such, programmers need to \sout{ensure that} /textit{evaluate whether} invalid data will be handled properly. After all, the Conferenceware group would be stymied if anyone on the planet \sout{were able to} \textit{could} arrest their code simply by sending invalid requests.  To avoid this, they perform extensive automated tests for invalid data and take advantage of any available resources. One such resource is DataAnnotations, which validates data in a declarative way and allows for the power and verification of underlying systems.  The team leverages these powerful tools and carries out careful testing to ensure that Conferenceware will be able to withstand the rigors of general use. 

The Conferenceware approach to development relies \sout{heavily} on planning \textit{combined with a healthy respect for available tools}. It \sout{utilizes} \textit{uses} a schema to prevent confusion and chaos down the line. During the development process itself, the Conferenceware group draws on organizational tools, which means that teams can focus on their work.  Then they complete the process with a regimented series of testing. In short, the Conferenceware team strives towards organization and structure, yet it also embraces any tools that can help achieve these goals. The programmers thus \sout{have} \textit{develop} a clear vision \sout{of what they must do} \textit{in advance}, but they \sout{are not overly encumbered by the actual process} \textit{also use resources that allow them to focus on the code itself}.
\end{mla}
\end{document}
