\documentclass[12pt,letterpaper]{article}
\usepackage{fancyhdr,geometry,setspace,mla,ulem}\pagestyle{fancy}

% 1 in margins
%\oddsidemargin 0.0in
\textwidth 6in
%\topmargin 0.5in
%\textheight 9.0in
%\headheight 0.0in
% double space
\doublespacing
\fancyhf{}
\begin{document}
\begin{mla}{James}{Wordelman}{Darko Marinov}{CS429}{\today}{Conferenceware
Design}
When we approach a large project, we must keep the entire design in mind all the time. Because Conferenceware is a project of considerable size and complexity, we need to keep conventions and separation consistent throughout the development process. Otherwise, we can not keep it 
in a manageable state. We strive to maintain cohesion when dealing with issues as course-grained as file management and as specific as module management or the content of the classes.  Our concern for consistent design extends to all aspects of the project.

We deal with literally hundreds of files for the main project alone, and supplemental changes (e.g., tests and documentation) add many more. Therefore, it is imperative to keep track of things. When writing Conferenceware, we use the language C\#, which can both hinder and facilitate our efforts.  C\# is very tolerant of different project structures. On the bright side, this means that we can choose to manage our files as we see fit most of the time, and the language will still understand and work flawlessly. But we can also make mistakes or poor decisions that the language will happily tolerate. Our choice in framework for the project, ASP.NET MVC, does impose two constraints for files, but the rest is a system respect\textit{ed} by everyone working on the project. The framework automatically creates folders that it suggests have certain uses. For instance, it provides a folder \texttt{App\_Data}, which is supposed to be used for private data (data which is not to be made
public to users on the internet).  The other folder that ASP.NET MVC provides is called Content, and it is where static files such as images or movies should be placed so they are accessible to users. There are also folders for Models (not actually enforced), Views, and Controllers. Controllers must all appear in the Controllers folder in the correct module (which is discussed below) and end with \texttt{Controller} in the file name. \sout{For instance, t} \textit{T}o make the \texttt{Dog} controller, the file would have to be named \texttt{DogController}. Views are also enforced to be in the Views folder. Inside of that folder, there are folders for each controller. Per the example \sout{before} \textit{above}, there would also be a folder named \texttt{Dog} inside of Views. This folder is where views specific to that controller must live. The only alternative is to use the special folder called Shared where files are made available to every controller.

This framework is a good beginning for files, but it is not extensive enough to keep everything in order, even if we adhere to every suggestion. We must implement additional rules to keep the project organized. Let us examine a simple example concerning views. Each controller has its own directory for its own views. We do come across certain conditions, however, when one view is needed by multiple controllers: for example, an error page for when a requested item is not found. If two controllers deal with this item (which is not completely rare when the controllers are closely related, as they are with \texttt{Companies} and \texttt{Invoices}), we should choose to reuse the same file rather than duplicating it. \sout{Therefore,} \textit{So} we keep a single version in \texttt{Shared}. We are then generally more able to limit the size of the \texttt{Shared} folder. On the other hand, we also uphold the rule that each class in the project is written in its own file even if it is small and only used in a single place. This increases the amount of files by a large amount. \sout{However, w} \textit{W}e insist on it because it makes finding classes much easier. We treat static files in a way that is similar to views, though Conferenceware can generally handle \sout{with} these files pragmatically on its own. \sout{For instance, e} \textit{E}ach event may well have content specific to the event (such as a recording of the event or any hand outs that were provided). \sout{As such, w} \textit{W}e keep a folder in \texttt{Content} for each event when it is added by the system. There are also static shared files. These can be things such as the site's style sheet or common JavaScript files. We keep these files in the root of \texttt{Content} which also shortens the file path (and can actually speed up web page load times). We do give users the option to organize content differently so long as it still is in the \texttt{Content} folder. We anticipate that there might be common hand outs between events: \sout{for example,} one speaker might give both a general talk and a very technical workshop. \sout{Alternatively, w} \textit{W}e might also have several files for a given event, including example files. \sout{In this case,} \textit{Then} our administrator \sout{may} \textit{might} want to categorize the files into folders. We can accomplish all of this by adjusting file locations manually on the file system outside of Conferenceware and then allowing the administrator to simply provide static links to the files. Our set-up provides the user with a great deal of flexibility while still maintaining logic and order within the files. We also uphold one final rule, which is that classes are placed in the folder of their module (so any class in the \texttt{Conferenceware.Utils} module will have its file located in the \texttt{Utils} directory inside of the \texttt{Conferenceware} directory). We want to have enough verbosity to find the files but still be able to keep track of them all quite easily, and this system fulfills that goal.

Moving to a more fine-grained idea, we have developed a design for creating and maintaining modules which ensures a complete and effective application. There are many parallels between our approach to files as described above and our module management. A module is a collection of classes that are grouped together. We must evaluate when to keep classes together and when to separate them.  We consider several factors when evaluating this problem; it is not just a matter of minimizing typing. We take the idea of reusability to heart. Though we might never reuse certain parts of the project on their own, others might be useful - in particular, the models. These classes represent the data that is handled in the Conferenceware universe. They could \sout{potentially} benefit another developer who wants to create a separate conference management system or even just one who wants to integrate with Conferenceware. \sout{Consequently, w} \textit{W}e want to be certain that all of the files used in managing data are in this module. We also want to include classes containing metadata about each of these classes. The metadata provides a more complete picture about the data and how it should and should not be used. \sout{As such, i} \textit{I}f we omit it, there is ambiguity and an otherwise incomplete system. Some classes that are created for Conferenceware do not exactly fit with the rest. Sometimes this is very stark such as with the \texttt{Mailer} class. This class exists for the sole purpose of sending email based on certain settings in an environment with \texttt{SettingsData}. It doesn't actually display anything, control anything (as a controller does), or manage data. It functions as a utility, so it has been placed in \texttt{Conferenceware.Utils} with things that have a similar purpose. These classes generally exist to help with a single action and nothing else. We have come across some subtle differences when trying to display a picture to the screen. Normally we use controllers to render a view or, when they are done processing, to redirect to a different action. When we want to display a picture, it is like a simple view in some ways, but we must also convey some additional data. Because of this special case, we need\sout{ed} to create a special result. It essentially functions in addition to the controllers (and is required by the controllers for them to function). These classes do not function on their own at all, and as such actually sit in the Controllers module. Again, we weigh how reusable these classes would be by themselves. By posing this simple question, we are able to keep modules reasonable, and the project remains much more manageable as it grows.

At the lowest, most specific level that we can manage with C\#, we must plan the design of individual classes. We decide which classes should be created and then what should be placed into them. When working through the latter problem, we remember that what is placed into each class is very directly related to the data it manages. In fact, we are using a library called LINQ (Language INtegrated Query) which gives a direct mapping between classes in Conferenceware and tables in the database. This allows us to manipulate our data very directly. Often, we may want to add some additional features beyond just data accessors to a class.  Sometimes we accomplish the objective through data processing. This can be used for converting internal data into something more functional, such as getting just the filename from a full file path. Alternatively, it might be able to convert unprocessed data like raw input from the user into something that is usable by the system internally.  In theory, we would naturally want to pair these methods with the class which stores the processed data.  \sout{At times, though,} \textit{But} we find that they are sometimes even more useful as helper classes, so that multiple classes can use them independently but as a collection of similar data processing methods. Conference creates extra classes rather often simply because C\# is a strongly typed language. As developers, we can profit by exploiting this; we are able to find bugs earlier and create more reusable data.  For instance, when creating an event, we need to keep track of all the data in the event as well as a full list of locations and all the times that are available for holding the event. Thus we have created a class called EventEditData that holds these three aspects. It allows all of the views to generate certain aspects for the developer and validate data much more simply. \sout{Also, w} \textit{W}hen processing data or handling other aspects of event management, we might need the same data again. We can now just invoke the same class an additional time instead of being inconsistent. This does create additional classes to manage, but it keeps the overall development experience very verbose and therefore very predictable. Such predictability also massively increases maintainability. All of these aspects culminate to allow us to create a better project.

As a project grows, its design is tested. Conferenceware has shown that a well defined and very verbose design can stand up to a lot of growth of a code base. Conferenceware is therefore free to grow to become a full featured application which can be used and maintained for the future. Instead of being a source of frustration and constraints, a good design can bring tremendous benefits to a project.
\end{mla}
\end{document}
